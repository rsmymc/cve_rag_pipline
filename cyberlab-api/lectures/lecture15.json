{
    "lecture_id": 7,
    "lecture_name": "lecture15",
    "lecture_content": "Page 1 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 0, 'page_label': '1'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nJava Input & Output\nMarch 19, 2024\n1\n--------------------------------------------------\nPage 2 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 1, 'page_label': '2'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRemember to Record to \nPanopto!\n2\n\n--------------------------------------------------\nPage 3 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 2, 'page_label': '3'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOverview\n- Reading Assignment 8 - Covers Chapter 9!\n- Will be on the exam\n- Ungraded - does not count toward your final grade\n- But the content will be on the exam\n- Test 2 - On Tuesday, March 26 at 10AM\n- Practice exam out on Friday\n- Project One\n- Lab tomorrow will be devoted to any questions folks may have!\n- No new lab will be issued - it is just for folks who have outstanding issues with the Project.\n- Today’s Lecture\n- Java Input and Output\n- There is a lot to learn!\n3\n--------------------------------------------------\nPage 4 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 3, 'page_label': '4'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nReading Assignment 8\nDo the questions.  They \nare not that terribly hard -\nbut it is important to know \nthis.\nAgain, will not count \ntoward your final grade \nbut the content will be on \nthe exam!\n4\n\n--------------------------------------------------\nPage 5 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 4, 'page_label': '5'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nProject One Tips and Pointers\n- When you refer back to Lab 5 - the context you need to \nsend along with the request is the transcript the user \nselected.  So, if the user entered “Query 1” - then you \nsend transcript 1 as the context.\n- Test 8 might pass initially with no code - just the class \nimplementation.  Once you add the Scanner - it will fail.\n- And String assignment.  What will this do:\nuserCommand.toUpperCase();\nprocessCommand(userCommand);\n5\n--------------------------------------------------\nPage 6 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 5, 'page_label': '6'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStreams and IO\nWe have been using streams and IO since day 1. Every \nlanguage that prints “Hello world” does this. A function that \nallows you to print to the screen - but more than that.\nIt’s an odd sort of syntax to introduce Java.  \nSystem.out.println(“Tell me something”);\n6\n--------------------------------------------------\nPage 7 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 6, 'page_label': '7'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIt Is Detailed in the Java API\n7\n\n--------------------------------------------------\nPage 8 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 7, 'page_label': '8'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nYou Can Even Look at the Java Source Code\nIf we had done this on day one - it would not have made sense.\n8\nIt’s an:\n1. Object\n2. Defined statically\n3. Publically available\n4. Final makes it \nimmutable\n--------------------------------------------------\nPage 9 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 8, 'page_label': '9'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSystem.out is a PrintStream\n9\nThis is a class hierarchy.  \nWe will dive into \ninheritance after the \nbreak!\n--------------------------------------------------\nPage 10 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 9, 'page_label': '10'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nPrintStream Constructors and Methods\n10\n\n--------------------------------------------------\nPage 11 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 10, 'page_label': '11'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSo … Could We Create Our Own Console Writer? \nIs it easy or hard to create our own PrintStream that writes to the console? \nYes, it’s very easy!  Look at Main.java.  \nThe concept of \"standard output\" (often abbreviated as stdout) originates \nfrom the early days of computing, particularly from the UNIX operating \nsystem and its predecessors.\nIn those early systems, the \"standard output\" was indeed typically \nconnected to the console, which was a text-based terminal where users \ninteracted with the system. As a result, writing to stdout meant displaying \ntext on the console screen.\n11\n--------------------------------------------------\nPage 12 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 11, 'page_label': '12'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCould We Change the Behavior or System.out\nYou know it!  Take a look at: \nRedirectSystemOutToFile.java\nSo, it is pretty easy to redirect to a file!\nWe will talking about resetting back to the console in a bit -\nit’s a special case.\n12\n--------------------------------------------------\nPage 13 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 12, 'page_label': '13'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStreams Eventually Have to Write or Read\n13\nSystem.out.println(“Hello!”);\nMain.java\nHello!\nflushed\nto\nconsole\nfile\nRAM\n--------------------------------------------------\nPage 14 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 13, 'page_label': '14'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFlushing\nThis is an important step.\nTrade offs:\n1. Flush often to get contents up to date in files.  Useful in some \nsituations but slow!\n2. Flush in bulk to be fast - but you do not have the most up to date \ncontent on file.\nLet’s look at an example!\n14\n--------------------------------------------------\nPage 15 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 14, 'page_label': '15'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFormatting Output\nSystem.out.printf(...)\n15\n\n--------------------------------------------------\nPage 16 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 15, 'page_label': '16'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThis is so 1970s or 1980s.  No one prints to the console …\nYes they do!  Writing to the console and redirecting the \noutput to files is essential to being a programmer: Logging  \nYou do this all the time when you place a \nSystem.out.println to test an expected state.  \n16\n\n--------------------------------------------------\nPage 17 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 16, 'page_label': '17'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFormatting Output in Log Files\n17\n\n--------------------------------------------------\nPage 18 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 17, 'page_label': '18'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThis Is Headed Toward an Art Form\nYou log output requires thought and should tell a story:\n18\n\n--------------------------------------------------\nPage 19 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 18, 'page_label': '19'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nReading Input From a File\nZybooks gives the \nfollowing example.\nWhat other things \nhave we read from \nfiles in the class?\n19\n\n--------------------------------------------------\nPage 20 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 19, 'page_label': '20'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIn Class Exercise\nBinary objects.\nThey are no a mystery.\nAny binary object is a \nsequence of bytes.  The \nsub-sequences have some \nmeaning or semantics.\n20\nExample PNG\nASCII Output\n--------------------------------------------------\nPage 21 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 20, 'page_label': '21'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nAgain, There is No Mystery!\nThere is the official guidance (which can be sort of like a \nmystery when you read it.)\nThen there are people who break it down for you - how to \nread and understand the file.\n21\n--------------------------------------------------\nPage 22 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 21, 'page_label': '22'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHow to Read the PNG DataStream\nPNG Signature: The first 8 bytes of a PNG file represent the PNG signature. These bytes are always 89 50 4E 47 0D 0A 1A 0Ain \nhexadecimal, which corresponds to the ASCII string ‰PNG\\r\\n\\x1A\\n. This signature indicates that the file is a PNG image.\n● You can verify the PNG signature by reading the first 8 bytes of the file and comparing them to the expected signature.\nChunk Structure: After the PNG signature, the file contains a sequence of chunks. Each chunk consists of four parts:\n● Length: A 4-byte integer indicating the length of the chunk data (excluding the length and type fields).\n● Chunk Type: A 4-byte ASCII string specifying the type of the chunk (e.g., IHDR, PLTE, IDAT, IEND).\n● Chunk Data: Variable-length data specific to the chunk type.\n● CRC (Cyclic Redundancy Check): A 4-byte CRC checksum of the chunk type and data, used for error detection.\n● You can read the length field (4 bytes) to determine the size of the chunk data.\n● You can then read the chunk type (4 bytes) to identify the type of the chunk.\n● Depending on the chunk type, you may need to interpret the chunk data in different ways. For example:\n● The IHDR(Image Header) chunk contains information about the image, such as width, height, bit depth, and color \ntype.\n● The PLTE(Palette) chunk contains a list of colors used in indexed-color images.\n● The IDAT(Image Data) chunk contains the compressed image data.\n● The IEND(End) chunk marks the end of the PNG file.\n22\n--------------------------------------------------\nPage 23 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 22, 'page_label': '23'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOur Goal\n1. Create a class that transforms a PNG file into a byte[] \narray.\n2. Read a chunk of the PNG data.\n3. Find the height and width of this image and print it out.  \nWe will need to read the specification!\n4. Find the colour type of the image (you need to do that!)\n23\n--------------------------------------------------\nPage 24 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 23, 'page_label': '24'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nTask 1: Create a byte Representation of the Image We Can Easily Access\nLook at the main method.  Let’s see what is happening \nhere.\nAny bets on what the second pir.readImage() will do when \nwe run it?\n24\n\n--------------------------------------------------\nPage 25 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 24, 'page_label': '25'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat a FileInputStreamis Doing\n1. A FileInputStream\nwill read the file directly \nfrom disk.\n2. When it reaches the end \nyou need to reset it back \nto its original position.\n3. Terribly inefficient for a \ncouple of reasons.\n25\nRead from disk\nImage1.png\n--------------------------------------------------\nPage 26 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 25, 'page_label': '26'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat Should we Do?\nWe know we want to access the elements of the file as bytes.\nThis probably means we map byte locations to logical names -\nlike the Palette chunk starts and ends here.\nA FileInputStream is ok - but its much better to just read it \nin as a byte[]and access the array.\nWhat are some tradeoffs of this approach? \n26\n--------------------------------------------------\nPage 27 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 26, 'page_label': '27'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLook at  readImageAsByteArray()\nThis does what we need!  \nIn the main method:\n1. Call it, \n2. Iterate over the byte[] imageAsByteArray.\n3. It has the contents persisted.\n27\n--------------------------------------------------\nPage 28 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 27, 'page_label': '28'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nTask 2: Read a Chunk of PNG Data \nHow do we access the data based on the specification? You \ngo to the locations indicate and manipulate the data. What \ndoes that mean?  The specification says:\nIf we print the first eight bytes, we should see this!\n28\n\n--------------------------------------------------\nPage 29 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 28, 'page_label': '29'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat is the & 0xFF Doing?\nYou have to convert (or cast) that byte to an unsigned int:\n-119:   10000001\n0xFF:   00000000 00000000 00000000 11111111\n-----------------------------------------\nResult: 00000000 00000000 00000000 10000001 (or 137!)\n29\n--------------------------------------------------\nPage 30 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 29, 'page_label': '30'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFinding the Height and Width of the Image\nIt’s all a matter of reading the standard.\nIt tells you the offset which to scan to to find that \ninformation.\n30\n--------------------------------------------------\nPage 31 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 30, 'page_label': '31'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCSC 213 Large Scale \nComputer Programming\nLecture 22\n31\n--------------------------------------------------\nPage 32 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 31, 'page_label': '32'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRemember to Record to \nPanopto!\n32\n\n--------------------------------------------------\nPage 33 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 32, 'page_label': '33'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOverview\n- Plan for this week\n- Tuesday - Build Automation Lecture\n- Wednesday - Build Automation Lab\n- Thursday - Wrap up threads and Final Exam review\n- Build Automation Lecture\n- Seeing is believing\n- Welcome to the best maven tutorial ever!\n33\n--------------------------------------------------\nPage 34 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 33, 'page_label': '34'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 1: Review this github project.\nOpen this URL here:https://github.com/mkyong/maven-examples\n34\nItems to note:\n1. It is one github project.\n2. It assumes you only need maven \nto build and run the project.\n3. It actually contains multiple \nprojects.\nWhat does that mean?  It contains \nmultiple projects.  Read the logical \nnames - they make sense.\n--------------------------------------------------\nPage 35 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 34, 'page_label': '35'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nAn Example Project Within\nThe sample java-project.\n35\nItems to note:\n1. This is the key to maven.\n2. It is called a “pom” file.\n3. It is the soup to nuts set of \ndirections on how to build, test, and \nrun the application.\n4. Think of a pom file as the \ncreators of the projects \ncomputationally defining how to \nuse the project.\n--------------------------------------------------\nPage 36 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 35, 'page_label': '36'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 2. Let’s Explore the java-project  \nHere are some typical things you will see for a mavenized \nJava project.  Note, this may be different for languages like \nPython or C++.\n1. The mainand testdirectories.\n2. The package structure.\n3. The source Java source code.\n36\nThis is an individual maven project\nHere is its source\nIt is divided into main and tests\n--------------------------------------------------\nPage 37 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 36, 'page_label': '37'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nJava Source Code\nFound in: /maven-examples/java-project/src/main/java/com/mkyong/hashing/\n37\nReasonable - right?\nBut, what about this?  \nThoughts?\nThe pom.xml file will \ncome into play here!\n--------------------------------------------------\nPage 38 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 37, 'page_label': '38'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 3.  Look at the pom.xml\nOur first peek at \ncomputationally defining how \nto use the project.\nNote, a human can read it just \nas well!  We will!\nBut it’s made to direct and \nguide a maven.\nIt is the instruction set, the \nrecipe if you will. \n38\nIt’s Awfully Long!\n--------------------------------------------------\nPage 39 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 38, 'page_label': '39'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 3a. Pom File Project Information Section\n● <modelVersion>: specifies the version of the POM model \nused for the project, in this case, version 4.0.0.\n● <groupId>: specifies the unique identifier of the project's \ngroup or organization. This is typically a reversed domain \nname.  Looks like the package structure!!\n● <artifactId>: specifies the unique identifier of the \nproject's artifact, which is the resulting output of the build \nprocess.  We will see this momentarily!!\n● <packaging>: specifies the type of artifact to be produced, \nin this case, a jar (Java archive) file.\n● <version>: specifies the version of the project's artifact.\n● <name>: specifies the name of the project.\n● <url>: specifies the URL of the project's homepage.\n39\nProject Information Section\n--------------------------------------------------\nPage 40 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 39, 'page_label': '40'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nPom Model Versions\n1. Maven 1.x Project Model: The first version of Maven was released in 2002 and used the Maven 1.x project \nmodel. This model was based on Ant and used an XML -based format for configuration.\n2. Maven 2.x Project Model: In 2005, Maven 2 was released, which introduced a new project model that was \nmore flexible and powerful than the previous version. The Maven 2.x project model is based on a simpler \nXML format called Project Object Model (POM), which contains all the information required to build a \nproject.\n3. Maven 3.x Project Model: Maven 3 was released in 2010 and brought several improvements and new \nfeatures. However, the project model remained the same as the Maven 2.x project model, with only minor \nchanges.\n4. Maven 4.x Project Model: As of May 2023, there is no official release of Maven 4 yet. However, the Maven \ncommunity is actively discussing and working on the next version of Maven, which is expected to bring \nsignificant changes and improvements to the project model.\nThe example project is using the beta version of Pom 4.0\n40\n--------------------------------------------------\nPage 41 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 40, 'page_label': '41'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 3b. Project Properties\nPretty straight forward.\nThe source code is encoded as UTF -8\nThe Java compiler is specified.  It is 1.8.  \nThis is critically important.  You can specify and enforce the compiler version use to \nbuild and run the project!\n41\n\n--------------------------------------------------\nPage 42 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 41, 'page_label': '42'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 3c. Dependencies - Pom’s Real Power! \nDependency management is a critical \ncomponent (maybe the most important?) \nfor pom.  \n● groupId: This element specifies the group or organization \nthat the dependency belongs to. In this case, the group ID \nis commons-codec, which is the ID for the Apache \nCommons Codec project.\n● artifactId: This element specifies the name of the \nlibrary or module being depended on. In this case, the \nartifact ID is also commons-codec, which refers to the \nspecific module within the Apache Commons Codec \nproject.\n● version: This element specifies the version of the \ndependency to be used. In this case, the version is 1.11, \nwhich indicates that version 1.11 of the Apache Commons \nCodec library should be used.\n42\nDependencies Section\n--------------------------------------------------\nPage 43 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 42, 'page_label': '43'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHow Do Dependencies Work?\nMVN Central - It is literally a \nrepository that holds versions of \nlibraries for Java!\nhttps://central.sonatype.com/artifact/commons-codec/commons-codec/1.15\nLook at the commons-codec \npage!\nWho pays for it? Sonatype, a tool \nprovider, via sponsorships and \ndonations.  Internal to a \ncompany you would use Nexus.\n43\nMVN Central Entry for commons-codec\n--------------------------------------------------\nPage 44 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 43, 'page_label': '44'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 3d. Specifying the JAR Target\nThis section of the pom file indicates \nhow to build the target jar file.  \nThe <configuration> block specifies the \nconfiguration options for the plugin. In this case, it \nis specifying that the archive should include the \ndependencies by using the jar-with-\ndependencies descriptor, and the main class for \nthe application should be specified in the manifest \nfile.\nThe <executions> block specifies when the plugin \nshould be executed. In this case, it is configured to \nexecute during the package phase, and the \nattached goal is used to generate a separate \nartifact that includes the dependencies.\n44\n\n--------------------------------------------------\nPage 45 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 44, 'page_label': '45'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 4. Build the Project\nHere are the directions to build.  You need to understand \nthe Maven build process as there is a lot here in a few, brief \ncommands!  \nReally, it is just one command to build it: mvn package\n45\n\n--------------------------------------------------\nPage 46 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 45, 'page_label': '46'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nMaven Build Lifecycle\n1. Compile phase: This phase compiles the main source code of the project.\n2. Test phase: This phase runs tests on the compiled source code using a testing \nframework such as JUnit.\n3. Package phase: This phase packages the compiled source code and resources \ninto a distributable format such as JAR, WAR, or ZIP.\n4. Install phase: This phase installs the packaged artifact into the local Maven \nrepository, so it can be used as a dependency by other projects on the same \nmachine.\n46\nmvn package calls all these beneath!\n--------------------------------------------------\nPage 47 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 46, 'page_label': '47'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat is Generated by the Build Process?\nA dependency-reduced-pom.xml is a generated POM file that contains only the \ninformation about the dependencies that are actually used in the project, and \nexcludes any unused dependencies. This is generated by the Maven Dependency \nPlugin and can be used to simplify the build process and reduce the size of the final \nartifact.  It optimizes transitive dependencies!\ntarget - the build process output!  What is expected to be there! \n47\n\n--------------------------------------------------\nPage 48 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 47, 'page_label': '48'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 5.  Look at the targetfolder output\nWow, there is a lot here!\n● classes: This folder contains the compiled class files of your project's main source code.\n● generated-sources: This folder contains any generated source code produced by tools like annotation processors.\n● generated-test-sources: This folder contains any generated source code produced by tools like annotation processors, \nspecifically for your tests.\n● maven-status: This folder contains files that Maven uses to keep track of the state of your project during the build.\n● original-java-project-1.0-SNAPSHOT.jar: This is the original, unmodified JAR file produced by the build.\n● java-project-1.0-SNAPSHOT.jar: This is the final, modified JAR file produced by the build, which includes any \nmodifications like resource filtering or class relocation.\n● surefire-reports: This folder contains the test results generated by the Surefire plugin, including reports and logs.\n● test-classes: This folder contains the compiled class files of your project's test source code.\n48\n\n--------------------------------------------------\nPage 49 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 48, 'page_label': '49'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLook at the SureFire Tests\nRunning the tests because a step in the automated build \nprocess.\nYou will see failures.\nYou will see the output as well, recorded for all time.\n49\n\n--------------------------------------------------\nPage 50 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 49, 'page_label': '50'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThis is Great … But …\nWe specified a dependency.\nWhere did it go?\nIt’s not in the target folder …. So where is it?\nIn your maven repository!\nEach user that runs maven gets one.  You didn’t even know that!  They can \nbe shared if you would like! \n50\n--------------------------------------------------\nPage 51 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 50, 'page_label': '51'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStep 6. Find the Dependency\ncd  into \n~/.m2/repository/commons-codec/commons-\ncodec/1.11\nThis holds the commons-code repository!\n51\n\n--------------------------------------------------\nPage 52 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture15.pdf', 'page': 51, 'page_label': '52'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\n8. Let’s Fail a Test\nYou are GUARANTEED that the project on Wednesday will \nhave a failing test!  It will be easy to fix.  But - it will be \nfailing!\nChange AppTest.java to fail.  I know - we are forcing this to \nbe incorrect!\n52\n\n--------------------------------------------------\n"
}