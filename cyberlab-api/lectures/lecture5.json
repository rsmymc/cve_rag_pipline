{
    "lecture_id": 18,
    "lecture_name": "lecture5",
    "lecture_content": "Page 1 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 0, 'page_label': '1'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nConstants and Control Flow\nJanuary 30, 2024\n1\n--------------------------------------------------\nPage 2 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 1, 'page_label': '2'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRemember to Record to \nPanopto!\n2\n\n--------------------------------------------------\nPage 3 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 2, 'page_label': '3'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nTime Management \nAssignment 2:\n3\n\n--------------------------------------------------\nPage 4 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 3, 'page_label': '4'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOverview\n- Lab updates\n- Lab 1 - You just have to submit it!  \n- Lab 2 - This will be graded\n- Java programming\n- Constants - overlooked but useful\n- Libraries\n- Control Flow\n4\n--------------------------------------------------\nPage 5 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 4, 'page_label': '5'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nConstants & Why They Matter\nIt comes down to consistency.  Take a look at the class \nConstantsExample.java\nhttps://docs.oracle.com/en/java/javase/17/docs/api/\n5\n\n--------------------------------------------------\nPage 6 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 5, 'page_label': '6'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nConstants Should Explain Logic of Application\nSomewhat worse, look at the class\nShippingCalculator.java\nWhy is this class so poor?\nEven something so small can be so \nproblematic\n6\n● Lack of clarity\n● Maintenance \nChallenge\n● Readability\n● Understandability\n--------------------------------------------------\nPage 7 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 6, 'page_label': '7'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nA Real World Example\n7\n\n--------------------------------------------------\nPage 8 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 7, 'page_label': '8'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThe Types of Things that Become Constants\n8\nApache NiFi: https://github.com/apache/nifi\n--------------------------------------------------\nPage 9 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 8, 'page_label': '9'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOnto Bytes                                       \nThere are primitive types in Java; not everything is an Object.  \nThough all primitives have a corresponding Object type.\nOne item discussed is the ‘byte’ type.\nMakes sense it’s the binary storage type.  So, what is a byte?   \n9\nbyte\nbit\n--------------------------------------------------\nPage 10 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 9, 'page_label': '10'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHow Data is Stored on Disk, RAM, and CPU\nWe examined the .class \nfile with xxd.  Let’s look at \nsomething even simpler!  \nLet’s look at the ASCII text \nof the Gettysburg address.  \nThis will be helpful.\n10\n\n--------------------------------------------------\nPage 11 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 10, 'page_label': '11'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nDecimal to Bytes to Hex\n11\nThe three types you need to \nknow:\n- Number (base 10 \ncounting)\n- Binary (base 2 \ncounting)\n- Hexadecimal (base 16 \ncounting)\nHalf bytes or nibbles!\n--------------------------------------------------\nPage 12 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 11, 'page_label': '12'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHow Data is Laid Out in RAM\n12\nRAM\nA big table of memory \nlocations that hold bytes\nRelative addresses\n--------------------------------------------------\nPage 13 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 12, 'page_label': '13'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThe Signed Integer Types\n13\nImplications for storage when you use these types. \nLet’s see.  Head to the Zylabs in-class exercise.\nSigned\n--------------------------------------------------\nPage 14 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 13, 'page_label': '14'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFloating Point\n- Decimal (or fractional) numbers represented with float or double.\n- There are limitations with respect to precision that may be \nrepresented.\n- So:\n2.0 - 1.7 = 0.30000000000000004\nThis matters a lot.  There is simply no precise binary representation \nfor this.  Though primitive wrappers may mitigate this.\nLet’s run MathExamples.java\n14\n--------------------------------------------------\nPage 15 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 14, 'page_label': '15'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nInfinity and NaN - The Tidbits of a Language Matter\nWhat about something like: 10.0 / 0.0\njshell> 10/0\n|  Exception java.lang.ArithmeticException: / by zero\n|        at (#4:1)\njshell> 1.0/0.0\n$5 ==> Infinity\njshell> 10.0/0.0\n$6 ==> Infinity\njshell> 0.0 / 0.0\n$7 ==> NaN\njshell> \n15\n--------------------------------------------------\nPage 16 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 15, 'page_label': '16'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nJava a Strongly Typed Language\nYou declare a variable and its type - and that variable can only hold that type going forward.  \nThis is unlike Python.\nYou can do (odd) things like: \nint total = 0, count;\nTypically separate declarations. \nConsider:\nRandom generator = new Random();\nOr (varadded in Version 10, 2018!)\nvar generator = new Random();\n16\nLesser used constructs: \nStringresult = (number % 2 == 0) ? \"Even\" : \"Odd\";\n--------------------------------------------------\nPage 17 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 16, 'page_label': '17'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nType Conversion\n1. If both operands are of the same type, no conversion is necessary.\n2. If one operand is of a type that can be promoted to the type of the other operand, the operand will be \npromoted to the type of the other operand. For example, if you divide a float by an int, the int will be \npromoted to a float before the division takes place.\n3. If both operands are of different types, and neither can be promoted to the other, then the result of \nthe operation will be of the type that can hold the larger range of values. For example, if you divide an \nint by a long, the result will be of type long.\n4. In case of mixed type arithmetic operation if any operand is of type double, the result is of type \ndouble.\n5. In case of mixed type arithmetic operation if any operand is of type float, the result is of type float.\n6. In case of mixed type arithmetic operation if any operand is of type long, the result is of type long.\n7. In case of mixed type arithmetic operation if any operand is of type int, the result is of type int.\n8. In case of mixed type arithmetic operation if any operand is of type short or byte, the result is of type \nint.\n17\nThis is A LOT!  Good practice:  Cast or turn one of the \nvariables into the type of the other BEFORE the \noperation.  Do not mix types in arithmetic operations … \nbecause you need to consult this.  \n--------------------------------------------------\nPage 18 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 17, 'page_label': '18'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nBigNumbers\nEventually - you reach the limits of what can be represented.  Take a \nlook at IntegerOverflowin the ZyLab.\nOr, you want precise answers.  \nEnter BigNumbers:\nvar k = new BigInt(“1111111111111111111111111111111111111111111111111”);\nvar l = new BigInt(“1111111111111111111111111111111111111111111111111”);\n18\nWhat is the trade off with using BigNumbers?\n--------------------------------------------------\nPage 19 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 18, 'page_label': '19'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nGetting a Development Team on the Same Page\nStyle guide and code reviews!  These are the two essential \nways!  Good programmers simply follow the style guide:\n19\n\n--------------------------------------------------\nPage 20 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture5.pdf', 'page': 19, 'page_label': '20'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIn-Class Exercise\nLet’s code a solution together to:\n2.27 LAB: Using math methods\n20\n--------------------------------------------------\n"
}