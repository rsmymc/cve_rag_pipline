{
    "lecture_id": 10,
    "lecture_name": "lecture18",
    "lecture_content": "Page 1 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 0, 'page_label': '1'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIntroduction to Inheritance\nLecture 18\n1\n--------------------------------------------------\nPage 2 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 1, 'page_label': '2'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRemember to Record to \nPanopto!\n2\n\n--------------------------------------------------\nPage 3 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 2, 'page_label': '3'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nTime Management\nThere will be two more assignments:\n1. One Reading assignment\n2. The final coding assignment!  Last one.\n3\n--------------------------------------------------\nPage 4 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 3, 'page_label': '4'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOverview\n- Interfaces - get ready\n- Using and implementing Interfaces\n4\n--------------------------------------------------\nPage 5 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 4, 'page_label': '5'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThe Need for Interfaces\nConsider the random number generator.  There are many \nways to implement the randomness of the generation.\n5\nRandom Generator Interface - the idealized \nrandom number generator\nRandom\nSecure Random\nSplittable Random\nThread Local \nRandom\nImplementations of that \nidealized interface\n--------------------------------------------------\nPage 6 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 5, 'page_label': '6'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nInterface - It’s Not a Hierarchy\n1. An interface defines a contract that a class must adhere to. It specifies a set of abstract \nmethods (methods without implementation) that any implementing class must provide.\n2. Unlike class hierarchies, interfaces do not provide any implementation details. They focus \nsolely on defining what a class should do, not how it should do it.\n3. Interfaces allow multiple inheritance in Java. A class can implement multiple interfaces, \neffectively providing several “views” or capabilities.\n4. Key points about interfaces:\n○ An interface can extend other interfaces, inheriting their methods and requirements.\n○ A class implementing an interface must explicitly provide implementations for all the \nmethods declared in that interface.\n○ Interfaces are useful for achieving polymorphism—you can use an instance of an \nimplementing class wherever the interface type is expected.\n6\n--------------------------------------------------\nPage 7 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 6, 'page_label': '7'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat Is In the Interface?\nMethods you wish all implementations to have.\n7\nAnd many many many more: \nhttps://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/random/RandomGen\nerator.html\n--------------------------------------------------\nPage 8 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 7, 'page_label': '8'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhy Might You Want Different Random Generators?\nIsn’t one enough?  Are they really needed? Let’s see.\nRandom- An instance of this class is used to generate a stream of pseudorandom numbers; its \nperiod is only 248. The class uses a 48-bit seed, which is modified using a linear congruential \nformula. \nSecureRandom- A cryptographically strong random number minimally complies with the \nstatistical random number generator tests specified in FIPS 140-2, Security Requirements for \nCryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-\ndeterministic output. Therefore any seed material passed to a SecureRandom object must be \nunpredictable, and all SecureRandom output sequences must be cryptographically strong, as \ndescribed in RFC 4086: Randomness Requirements for Security.\n8\nYou need to FIPS compliant!\n--------------------------------------------------\nPage 9 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 8, 'page_label': '9'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nGovernment Software Requirements\nThere are more and more everyday - many related to \ncybersecurity.\n9\n\n--------------------------------------------------\nPage 10 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 9, 'page_label': '10'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRandom versus SecureRandom\nIn Java, java.util.Random class generates pseudorandom numbers that are deterministic, which \nmeans that the sequence of generated numbers can be repeated by providing the same \ninitial seed value. This makes it unsuitable for security -critical applications where true \nrandomness is required.\nVersus\nOn the other hand, java.security.SecureRandom class generates cryptographically strong random \nnumbers that are designed to be unpredictable and non -repeating. The implementation of \nSecureRandom is designed to gather entropy from various sources, such as system events \nand user input, to provide a higher level of randomness. It is not deterministic, meaning that \nthe sequence of numbers generated by SecureRandom cannot be predicted, even if the \nsame seed is used.\n10\nfaster & less computationally expensive!\n--------------------------------------------------\nPage 11 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 10, 'page_label': '11'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRandom versus ThreadLocalRandom \nUsing ThreadLocalRandom in a multi-threaded application can be beneficial because it reduces \ncontention for a shared random number generator, such as Random, which could result in multiple \nthreads trying to access the same random number generator and waiting for access. In contrast, \neach thread has its own instance of ThreadLocalRandom, which avoids contention and can improve \nperformance. Literally: \n11\nThread1\nThread2\nThread3\nAll use the same instance of \nRandom.  Likely to have the \nsame sequence of ‘random’ ints\n--------------------------------------------------\nPage 12 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 11, 'page_label': '12'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nAn Overview of Threads - What Are They!\n12\nThey are like a \nprocess - just a \nsub-process of \none.\n--------------------------------------------------\nPage 13 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 12, 'page_label': '13'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThe Moral of The Story\n- Sometimes you can have a wonderful interface\n- But the first or original implementing class has a \ndeficiency for a specific use case or requirement.\n13\n\n--------------------------------------------------\nPage 14 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 13, 'page_label': '14'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nInterfaces Evolve: RandomGenerator is  GREAT Ex ample\n14\nRandom \nGenerator\nJava 1.0 1996\n“Folks, we have a \nrandom number \ngenerator!”\nJava User\nJava Creator\n“Uh ….”\n“About that random \nnumber generator.  \nIts deterministic.  Oh, \nand it’s not thread \nsafe.”\n“Folks, we have a \nrandom generator \ninterface!”\nRandom \nSecure \nRandom \nThread \nLocal \nRandom \nJava 1.2 1997\n--------------------------------------------------\nPage 15 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 14, 'page_label': '15'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nDeclaring an Interface\nHere is a neat example.  A different kind of number sequence.  Ones that can be \ndifferent kinds and may or may not be random.  They only yield integers:\n- Sequence of integers provided by a user\n- Sequence of random integers\n- Sequence of prime numbers\n- Sequence of elements in an integer array\n- Sequence of code points in a string\n- Sequence of digits in a number\nWe want to implement a single mechanism for dealing with all these sequences \n15\n--------------------------------------------------\nPage 16 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 15, 'page_label': '16'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCommonality Between Integer Sequences\n- Test whether there is a next element.\n- Get that next element\nYou declare an interface like so:\n16\nSame as a class except … an interface!\nFor the NiFi project we \nreviewed, there were 8000 \nJava files.\nAny guesses as to how \nmany of these were \ninterfaces?\n--------------------------------------------------\nPage 17 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 16, 'page_label': '17'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFrom ZyBooks Lab Let’s Do This\nOpen IntSequence.java, InterfaceDemo.java, & SquareSequence.java Where do you think \nthey are? They are in the Lecture 9 folder somewhere!\n17\nDefines it\nImplements it\nUses it\n--------------------------------------------------\nPage 18 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 17, 'page_label': '18'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nFirst, Let’s Compile Them\nNote, there is just the interface and the demo class that uses \nit.  There is no class that implements the interface.  So … \nwill it compile?\n> javac -d classes/ *.java\n18\n--------------------------------------------------\nPage 19 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 18, 'page_label': '19'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLet’s Add to Main Method in InterfaceDemo!\nAdd this to the main method:\nIntSequence intseq = new SquareSequence();\nfor(int i = 0; i < 10; i++){\nSystem.out.println(intseq.next());\n}\nCompile it.\nRun it with this command:\n> java -cp classes InterfaceDemo\nGreat!  Now change the counter value to be 250000.  Compile and run that!  What do you see.  Change it \nback to 10 once this completes.\n19\n--------------------------------------------------\nPage 20 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 19, 'page_label': '20'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLet’s Add More to Main Method \nOpen up the class \nDigitSequenceand \nlet’s take a look:\n20\nHmmm ….\n--------------------------------------------------\nPage 21 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 20, 'page_label': '21'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLet’s Add More to Main Method \nNow, add this to InterfaceDemo:\nintseq = new DigitSequence(1729);\ndouble avg = average(intseq, 100);\nSystem.out.println(avg); \n21\n--------------------------------------------------\nPage 22 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 21, 'page_label': '22'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSupertype and Subtype\n22\nsupertype\nsubtype\n--------------------------------------------------\nPage 23 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 22, 'page_label': '23'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nLet’s Add More to the Main Method\nDigitSequence has that rest() method.  So … how do we \naccess it?  Casting!\nDigitSequence digits = (DigitSequence)intseq;\nSystem.out.println(digits.rest());\n23\n--------------------------------------------------\nPage 24 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 23, 'page_label': '24'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCasting Can Go Any Direction\nLet’s look at InterfaceDemo\n24\nSuperclasses Interfaces\nDigitSequence\nObject IntSequence\n--------------------------------------------------\nPage 25 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 24, 'page_label': '25'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\ninstanceof Syntax\nif(obj instanceof DigitSequence){\nSystem.out.println(\"obj is a DigitSequence\");\nSystem.out.println(\"This casting stuff is annoying.\");\nSystem.out.println(((DigitSequence)obj).rest());\n}\nNow you just do:\nif(obj instanceof DigitSequence digits){\n25\nYou used to have to cast it.\nThen you had to reference it.\n--------------------------------------------------\nPage 26 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 25, 'page_label': '26'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\ninstanceof in a Real World Project - NiFi\nApache NiFi has around 2000 instances.  Let’s take a look at \none:\n26\n\n--------------------------------------------------\nPage 27 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 26, 'page_label': '27'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIf Evaluation - A Small Nuance\nThis compiles just fine:\nThis does not:\nWhy?\n27\n\n--------------------------------------------------\nPage 28 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 27, 'page_label': '28'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nMultiple Interfaces\n28\nWe know ArrayList\nClass hierarchy\nImplements many \ninterfaces\n--------------------------------------------------\nPage 29 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture18.pdf', 'page': 28, 'page_label': '29'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSerializable Interface\nHere is an example of a quite generic interface\n29\nExercise3\n--------------------------------------------------\n"
}