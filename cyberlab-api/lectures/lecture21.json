{
    "lecture_id": 14,
    "lecture_name": "lecture21",
    "lecture_content": "Page 1 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 0, 'page_label': '1'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIntroduction to Collections\nLecture 21\n1\n--------------------------------------------------\nPage 2 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 1, 'page_label': '2'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nRemember to Record to \nPanopto!\n2\n\n--------------------------------------------------\nPage 3 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 2, 'page_label': '3'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nOverview\nTime management:\n● Reading Assignment 11\n● Project 2\nIterators!\nCollections!\nHow to use these constructs as Lists, Maps, Properties file\nDemonstration of HashMap use case.\n3\n--------------------------------------------------\nPage 4 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 3, 'page_label': '4'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nTime Management\nProject 2 - Surprised?\n4\n\n--------------------------------------------------\nPage 5 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 4, 'page_label': '5'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCollections\n● In Java, a collection is a group of objects that are stored together and can be \naccessed using a common interface. \n● Collections provide a way to store and manipulate a set of objects in a \nstructured and efficient manner.\nKey point:\nA group of objects stored together.  A collection!  Like, a Pokemon collection, a coin \ncollection, a hat collection.  They are all the same type of object – just stored \ntogether in one place.\n5\n--------------------------------------------------\nPage 6 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 5, 'page_label': '6'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCollections\nThis is all about data structures.\nWe have used one already - ArrayList.  It happens to be the most common data \nstructure for Java - coming in second would probably be Maps(HashMaps)\nThe structure part needs to be conceptualized - in your head!\n6\nYou may draw out the data \nstructure\nYou may fill in the slots.\nThis part is helpful - drawing \nout the actual structure.\nCould be a good test question!\n--------------------------------------------------\nPage 7 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 6, 'page_label': '7'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nAlways Keep in Mind …\nA collection is represented by some data structure.\nThis data structure is filled in (or trimmed!) as the program runs.  \nAs the program runs - it uses the collection in some way.\n7\nIf you add the key / vals \nsequentially \nDraw out what the structure \nlooks like.\nVisualize it\nDrawing out data structures is a \nfirst step to understanding them!\n\n--------------------------------------------------\nPage 8 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 7, 'page_label': '8'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\n… Drawing Helps!\nThe code is almost like a person adding elements to a collection.  And making \ndecisions about where things go, how they get updated.\n8\nKey Value\nApple 1\nKey Value\nApple 1\nBanana 2\nKey Value\nApple 4\nBanana 2\nOrange 1\nPrintln Outputs\n[]\n[apple]\n[banana x 2, apple]\n[banana x 2, orange, apple]\n[banana x 2, orange, apple x 4]\n--------------------------------------------------\nPage 9 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 8, 'page_label': '9'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHistory of Data Structures\n9\nTimeline - computer power increases\nArrays, linked lists, and stacks\nBinary trees, hash tables, and graphs\nObject-oriented programming languages such \nas Java and C++ made it easier to define and \nmanipulate complex data structures, and new \ndata structures such as queues and heaps \nwere developed to support these languages.\n1940s -\n1950s\n1960s -\n1970s\n1980s -\n1990s\n2020s\nIt took a long time to get to this point!  There were \nnot developed “over night”\nChatGPT - its \nmodel is just \nanother data \nstructure.  It is an AI \nlanguage model.\n--------------------------------------------------\nPage 10 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 9, 'page_label': '10'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nJava Collections Framework\n10\n\n--------------------------------------------------\nPage 11 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 10, 'page_label': '11'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nNote, an array[] is a Collection Too\nBut – it does not implement the Collection Interface.  Here are the drawbacks:\n1. Lack of flexibility: Arrays are fixed-size collections, which means that their size cannot be changed \nafter they are created. This can make it difficult to work with dynamic data structures or to add new \nelements to an array after it has been created.\n2. Limited functionality: Arrays provide a limited set of methods for working with their elements, such \nas accessing and modifying individual elements, but they do not provide the same level of \nfunctionality as collections, such as sorting, searching, or iteratingover their elements.\n3. Fixed Size:  Yuck.  What happens when I reach the end of it?\n4. Limited type safety flexability: While arrays provide type safety in the sense that each element \nmust be of the same type as the array, they donot provide the same level of type safety as \ncollections, which can accept any type of object.\n5. No generic support: Arrays are not generic, which means that they cannot be used with generic \ntypes. This can limit their usefulnessin certain situations where generic types are necessary.\n11\n--------------------------------------------------\nPage 12 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 11, 'page_label': '12'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nWhat Does Iterable Mean?\nIt’s related to the mathematical concept of a sequence.\n1. Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, … Each number in the sequence is the sum of the two preceding \nnumbers.\n2. Prime numbers: 2, 3, 5, 7, 11, 13, 17, 19, 23, … A prime number is a positive integer greater than 1 that has no positive \ninteger divisors other than 1 and itself.\n3. Square numbers: 1, 4, 9, 16, 25, 36, 49, 64, 81, … Each number in the sequence is the square of the corresponding \ninteger.\n4. Triangular numbers: 1, 3, 6, 10, 15, 21, 28, 36, 45, … Each number in the sequence is the sum of the first n positive \nintegers, where n is the position of the number in the sequence.\nDates back to Euclid, called a sequence a progression. But the idea of \na sequence is quite old.  What computers did was allow them to be \nmanipulated much more easily than by hand. Changes everything!\n12\n--------------------------------------------------\nPage 13 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 12, 'page_label': '13'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIterable Realizes the Concept of Sequences\nIterables allow us to represent and manipulate \nsequences of values.  It makes them real is some \nsense.\nThese can be iterated over (e.g., processed, filtered, \ntransformed) in a uniform way, regardless of their \nunderlying representation or implementation. \nIterable is the construct that allows you to access \neach element of a sequence!\nWe can do better than what we see at the right!\n13\nIterate Over First N Fibonacci\n--------------------------------------------------\nPage 14 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 13, 'page_label': '14'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nExercise\n● Great.\n● Let’s look at the Iterator interface.\n● Let’s implement the code!\n● Then we’ll have an Iterable.  Which means we will need \nto implement Iterator.\n14\n--------------------------------------------------\nPage 15 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 14, 'page_label': '15'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCollection is the Holder or Vessel for a Sequence\nIterable allows you to go over a collection.  \nThe collection holds the elements and iterable gives you a construct to access each one.\n15\nI hold a linked list!  I am \nthe data structure.\nI give you a way to access my elements!\n--------------------------------------------------\nPage 16 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 15, 'page_label': '16'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nIterator API\n16\nObnoxious way to do it, pre-2004\nEasy way to do it!  Can anyone guess \nwhat magic allows the enhanced for \nloop bit from the API?\n--------------------------------------------------\nPage 17 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 16, 'page_label': '17'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nCollection API\n17\nThis is independent of the data \nstructure type - commonality!\n--------------------------------------------------\nPage 18 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 17, 'page_label': '18'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nThe ListInterface\nList<String> words = new ArrayList<>();\n1. ArrayList: It's a resizable array implementation that provides random access and supports dynamic resizing. It \nimplements the List interface and stores elements in a contiguous memory location , making it efficient for read operations. \nHowever, it can be slow for adding and removing elements from the middle of the list.\n2. Vector: It's similar to ArrayList but is synchronized, which makes it thread -safe. It also implements the List interface and \nprovides dynamic resizing, but the synchronization can add overhead, making it slower than ArrayList in some cases.\n3. LinkedList: It's a linked list implementation that stores elements as nodes, with each node having a reference to the \nprevious and next nodes. It implements the List and Deque interfaces and provides efficient insertion and removal of \nelements from the middle of the list, but can be slower for random access due to the need to traverse the list.\nSummary:  ArrayList is the most commonly used implementation for lists in Java, as it provides a good balance between \nperformance and functionality. Vector is mostly used in multi -threaded environments, where synchronization is necessary. \nLinkedList is best suited for use cases where frequent insertion and removal of elements is required, especially from the \nmiddle of the list.\n18\n--------------------------------------------------\nPage 19 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 18, 'page_label': '19'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nQueue - They are Used a Bunch!\nAnyone familiar with these? Ideal for handling requests that must be processed in the order \nwhich they are received.\nUses the FIFO principle - First In First Out.\nUsed by message queues: Apache Kafka, RabbitMQ, and LavinMQ\n19\nGPS coordinates of a drone\nDraws drone tracks\n\n--------------------------------------------------\nPage 20 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 19, 'page_label': '20'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSet Collection\nTests whether a value is an element.\nDoes not remember the the order in which elements were \nadded.\nReally is pretty straightforward.  \nWe saw at the beginning with respect to a Multiset.\n20\n--------------------------------------------------\nPage 21 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 20, 'page_label': '21'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nJava Collections Framework\n21\n\n--------------------------------------------------\nPage 22 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 21, 'page_label': '22'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nMaps\nArrayListsare probably the first most important Collectiontype.\nMaps, HashMapsin particular, are probably the second most!\nThey are incredibly useful, for operations like:\n1. Counting entities of a particular type or with a particular condition\n2. Fast retrieval of entities that match a particular characteristic\nKey (index) to another object (value) - You will hear this often:  key-value \npair.\nFast Lookup - that is the key!\n22\n--------------------------------------------------\nPage 23 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 22, 'page_label': '23'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nVery Common Map Scenario - Counting Items\nLet’s say I do the following in Java.  \n1. Generate 1000 random integers.  \n2. Sum up each random integer as follows: \na. For random integer \"82937493284\", \nb. The sum is 8+2+9+3+7+4+9+3+2+8+4  \n3. Make those:\na. Sums be the Keys, and the \nb. Values be how often that sum occurs \n23\nLet’s write this \none.\nMade for a HashMap!\n--------------------------------------------------\nPage 24 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 23, 'page_label': '24'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nHashMap Code\n24\nWithout this method … what would \nwe need to do?\n--------------------------------------------------\nPage 25 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 24, 'page_label': '25'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nProperties File\nThis is a common occurrence in Java - you want to specify \nproperties.  You have an application and users can set \nproperties.  Simple use case:\n25\n\n--------------------------------------------------\nPage 26 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 25, 'page_label': '26'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nSystem Properties - These Are Quite Useful\n26\n\n--------------------------------------------------\nPage 27 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 26, 'page_label': '27'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nStacks - Just Implemented as a Queue or Deque\nvar stack = new ArrayDeque<String>();\nstack.push(“Peter1”);\nstack.push(“Peter2”);\nstack.push(“Peter3”);\nwhile(! stack.isEmpty()){\nSystem.out.println(stack.pop());\n}\n27\n--------------------------------------------------\nPage 28 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 27, 'page_label': '28'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nUse of Texas Instruments Calculators Used a Stack\n28\n\n--------------------------------------------------\nPage 29 Metadata: {'source': '/Users/tylerderkovitz/downloads/lectureFile/Lecture21.pdf', 'page': 28, 'page_label': '29'}\n\nDepartment of\nComputer ScienceCSC 213: Large Scale Programming\nMeet the Cybersecurity and \nData Analytics Folks!\n29\n\n--------------------------------------------------\n"
}